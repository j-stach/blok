
use crate::{ Block, Layer };

/// Functions for modeling gaps and empty space:
impl<B: Block> Layer<B> {

    /// Add void blocks to the start of the row.
    pub fn offset_row(
        &mut self, 
        r: usize, 
        mut offset: usize
    ) -> anyhow::Result<&mut Self> { 

        if r >= self.layout().len() {
            return Err(anyhow::anyhow!("Row {} could not be found", r))
        }

        if offset == 0 { 
            return Ok(self) 
        }

        if self.layout[r] == 0 {
            self.add_block_to_row(r, B::void())
                .expect("Row exists because it was checked");
            offset -= 1;
        }

        for _ in 0..offset {
            self.insert_block(r, 0, B::void())?;
        }

        Ok(self)
    }

    /// Add void blocks to the end of the row.
    pub fn pad_row(
        &mut self,
        r: usize,
        pad: usize 
    ) -> anyhow::Result<&mut Self> {

        if r >= self.layout().len() {
            return Err(anyhow::anyhow!("Row {} could not be found", r))
        }

        for _ in 0..pad {
            self.add_block_to_row(r, B::void())
                .expect("Each row exists");
        }

        Ok(self)
    }

    /// Offset with an empty row.
    /// Rows contain a single void block so that they can be indexed.
    pub fn offset_x(&mut self, offset: usize) -> &mut Self {

        let mut layout = vec![0; offset];
        layout.append(self.layout_mut());
        *self.layout = layout;

        self
    }

    /// Offset all rows with void blocks.
    pub fn offset_y(&mut self, offset: usize) -> &mut Self {

        for r in 0..self.layout().len() {
            self.offset_row(r, offset)
                .expect("Error: Layout corrupted");
        }
        self
    }

    /// Insert empty rows at the end of the layer.
    pub fn pad_x(&mut self, pad: usize) -> &mut Self {

        for _ in 0..pad {
            self.new_row();
        }
        self
    }

    /// Add voids to the end of each row.
    pub fn pad_y(&mut self, pad: usize) -> &mut Self {

        let num_rows = self.layout.len();
        for r in 0..num_rows {
            self.pad_row(r, pad)
                .expect("Row exists if using layouts");
        }
        self
    }

    /// Square off the matrix to the highest row length,
    /// by inserting void blocks into the empty indices.
    pub fn realize_voids(&mut self) -> &mut Self {

        let mut rows = self.clone_into_blocks();
        let max = rows.iter()
            .map(|r| r.len())
            .max()
            .expect("There should be rows present in layer before considering voids");

        for r in rows.iter_mut() {
            while r.len() < max {
                r.push(B::void());
            }
        }

        self.set_from_blocks(rows);
        self
    }

    /// Square off the matrix up to the given x (row) and y (length),
    /// by inserting void blocks into the empty indices.
    pub fn realize_area(
        &mut self, 
        x: usize, 
        y: usize
    ) -> &mut Self {

        let mut rows = self.clone_into_blocks();
        for r in rows.iter_mut() {
            while r.len() < y {
                r.push(B::void());
            }
        }

        while rows.len() < x {
            rows.push(vec![B::void(); y])
        }

        self.set_from_blocks(rows);
        self
    }

    /// Replace all void blocks with ones generated by the given constructor.
    pub fn fill_voids(
        &mut self, 
        instructions: &B::CreationInstructions
    ) -> &mut Self {

        for block in self.blocks_mut().iter_mut() {
            if block.is_void() {
                *block = B::create(&instructions)
            }
        }
        self
    }

    /// Replace all void blocks with ones cloned from a prototype.
    pub fn fill_with_clones(&mut self, block: &B) -> &mut Self {

        for b in self.blocks_mut().iter_mut() {
            if b.is_void() {
                *b = block.clone()
            }
        }
        self
    }

    /// Remove all void blocks from the matrix.
    pub fn compress(&mut self) -> &mut Self {

        let mut rows = self.clone_into_blocks();
        rows = rows.into_iter()
            .map(|row| 
                row.into_iter()
                    .filter(|block| !block.is_void())
                    .collect()
            )
            .collect();

        // TODO Remove empty rows

        self.set_from_blocks(rows);

        self
    }

}


/*  UNIT TESTS  */
#[cfg(test)] mod test {

    // TODO: Need assert statements

    use crate::{ Block, Layer };
    use crate::types::layer::test::test_layer;

    #[test] fn offset_test() {

        let mut layer = test_layer();
        layer.offset_x(1);
        layer.offset_y(1);

        // assert void in x and y
    }

    #[test] fn pad_test() {

        let mut layer = test_layer();
        layer.pad_x(1);
        layer.pad_y(1);

        // assert void in x and y
    }

    #[test] fn realize_voids_test() {

        let mut layer = test_layer();
        layer.realize_voids();

        // 
    }

    #[test] fn realize_area_test() {

        let mut layer = test_layer();
        layer.realize_area(3, 3);

        //
    }

    #[test] fn fill_voids_test() {

        let mut layer = test_layer();
        layer.realize_voids();
        // layer.fill_voids

        layer.realize_area(3, 3);
        // layer.fill_with_clones

        // assert no voids
    }

    #[test] fn compress_test() {

        let mut layer = test_layer();
        layer.realize_voids();
        layer.compress();

        // assert 3 total, no voids
    }

}
