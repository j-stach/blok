
use super::*;

/// Functions for modeling gaps and empty space:
impl<B: Block> Layer<B> {

    /// Offset a row with void blocks.
    pub fn offset_row(
        &mut self, 
        row: usize, 
        offset: usize
    ) -> anyhow::Result<()> { // TODO Error
        
        if row > self.layout().len() {
            return Err(anyhow::anyhow!("Row {} could not be found", row))
        }

        for _ in 0..offset {
            self.insert_block(row, 0, B::void())?;
        }

        Ok(())
    }

    /// Offset with an empty row
    // TBD Void block or simple imaginary row?
    pub fn offset_x(&mut self, offset: usize) {
        let mut layout = vec![0; offset];
        layout.append(self.layout_mut());
        **self.layout_mut() = layout;
    }

    /// Offset all rows with void blocks.
    pub fn offset_y(&mut self, offset: usize) {
        for r in 0..self.layout().len() {
            self.offset_row(r, offset)
                .expect("Error: Layout corrupted")
        }
    }

    //
    // TODO
    // pad_x
    // pad_y
    //

    /// Square off the matrix to the highest row length,
    /// by inserting void blocks into the empty indices.
    pub fn realize_voids(&mut self) -> &mut Self {

        let mut rows = self.clone_into_blocks();
        let max = rows.iter()
            .map(|r| r.len())
            .max()
            .expect("There should be rows present in layer before considering voids");

        for r in rows.iter_mut() {
            while r.len() < max {
                r.push(B::void());
            }
        }

        self.set_from_blocks(rows);
        self
    }

    /// Square off the matrix up to the given x and y,
    /// by inserting void blocks into the empty indices.
    pub fn realize_volume(
        &mut self, 
        x: usize, 
        y: usize
    ) -> &mut Self {

        let mut rows = self.clone_into_blocks();
        for r in rows.iter_mut() {
            while r.len() < y {
                r.push(B::void());
            }
        }

        while rows.len() < x {
            rows.push(vec![B::void(); y])
        }

        self.set_from_blocks(rows);
        self
    }

    /// Replace all void blocks with ones generated by the given constructor.
    pub fn fill_voids(
        &mut self, 
        instructions: &B::CreationInstructions
    ) {
        for block in self.blocks_mut().iter_mut() {
            if block.is_void() {
                *block = B::create(instructions.clone())
            }
        }
    }

    /// Replace all void blocks with ones cloned from a prototype.
    pub fn fill_with_clones(&mut self, block: &B) {
        for b in self.blocks_mut().iter_mut() {
            if b.is_void() {
                *b = block.clone()
            }
        }
    }

    /// Remove all void blocks from the matrix.
    pub fn remove_voids(&mut self) {
        let mut rows = self.clone_into_blocks();
        rows = rows.into_iter()
            .map(|row| 
                row.into_iter()
                    .filter(|block| !block.is_void())
                    .collect()
            )
            .collect();

        self.set_from_blocks(rows)
    }

}
