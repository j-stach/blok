
use crate::{ Block, Stack };

//
// TODO:
// - Realize voids/volume without cloning
// - Collapse function
//

/// Functions for working with gaps and empty space:
impl<B: Block> Stack<B> {

    /// Square off the matrix to the highest row length,
    /// by inserting void blocks into the empty indices.
    pub fn realize_voids(&mut self) -> &mut Self {
        let mut max_x = 0usize;
        let mut max_y = 0usize;
        let mut layers = self.clone_into_layers();

        for layer in layers.iter() {

            let row_count = layer.layout().len();
            let max_index = layer.layout().iter().max();
            if row_count > max_x { 
                max_x = row_count 
            }

            if let Some(index) = max_index {
                if index > &max_y { 
                    max_y = *index 
                }
            }
        }

        for layer in layers.iter_mut() {
            layer.realize_area(max_x, max_y);
        }

        self.set_from_layers(layers);
        self
    }


    /// Square off the matrix to the provided dimensions by inserting voids into empty indices.
    /// (layer count, row count, block count)
    pub fn realize_volume(&mut self, dims: (usize, usize, usize)) -> &mut Self {

        while self.layouts().len() < dims.0 {
            self.new_layer();
        }

        let mut layers = self.clone_into_layers();

        for layer in layers.iter_mut() {
            layer.realize_area(dims.1, dims.2);
        }

        self.set_from_layers(layers);
        self
    }


    /// Replace all void blocks with ones generated by the given constructor.
    pub fn fill_voids(
        &mut self, 
        instructions: &B::CreationInstructions
    ) -> &mut Self {

        self.blocks.iter_mut().for_each(|b| {
            if b.is_void() {
                *b = B::create(instructions);
            }
        });

        self
    }

    /// Replace all void blocks with ones cloned from a prototype.
    pub fn fill_with_clones(&mut self, block: &B) -> &mut Self {

        self.blocks.iter_mut().for_each(|b| {
            if b.is_void() {
                *b = block.clone();
            }
        });

        self
    }


    /// Removes voids by layer while preserving non-void block count and ordering.
    pub fn compress(&mut self) -> &mut Self {
        let mut layers = self.clone_into_layers();
        for layer in layers.iter_mut() {
            layer.compress();
        }

        self.set_from_layers(layers);
        self
    }

    /* UNDER CONSTRUCTION 

    /// Removes voids by dropping "unsupported" blocks down from higher layers.
    fn collapse(&mut self) -> &mut Self {
        self.realize_voids();
        //let mut layers = self.clone_into_blocks();
        //assert!{layers.len() > 0, "A stack needs layers to use `Stack::collapse`"};
        // TODO

        // for each row in each layer
        // for each non-void block, shift down to the lower layer
        // if any shifted mark true
        // repeat for each layer
        // if true, collapse again

        // need "vertical" vectors transform


        // for each non-void block, if the layer below has a void block or no block in that row/index,
        // check the index/row of the layer below that, and so on, until one is found,
        // move the block to the empty layer/row/index above it & continue
        // NOTE: Do not remove voids, let collapse and compress be functionally separate

        todo![]
    }
*/
}
